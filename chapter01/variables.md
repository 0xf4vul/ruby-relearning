# 变量与基本算数

## 基本算数

### 整数运算

### 浮点数运算

### 布尔运算

## 局部变量

变量 (variable) 是程序开发的基础概念之一。变量是一种对临时存储的抽象概念。Ruby 中的变量有 4 种类型：

- 局部变量 `variable`
- 实例变量 `@variable`
- 类变量 `@@variable`
- 全局变量 `$variable`

这里所介绍的变量是局部变量，至于其它变量的时候，我们会在之后章节中再做介绍。

## Ruby 的类型系统

类型系统自古以来都是高级语言的一个非常重要的属性。基于不同的分类方法可以把不同语言的类型系统分成不同类别。一般我们会说 Ruby 的类型系统是一个动态类型、强类型系统。其中动态类型与静态类型相对，而强类型与弱类型相对。类型的动态与静态、强与弱是一对正交（orthogonal）的概念。

![Type System Example](/assets/type-system-example.png)

理解这一问题，我们先要理解类型可能的错误，以及错误带来的问题。

一类问题是出现在类似于 C 语言中的内存管理带来的错误。比如说根据某一变量的类型分配了一定空间，但是在写入的时候，占用了大于既定的空间。C 语言不会检查这一类的错误，从而造成程序写入到了其它变量 / 程序本来占用着的空间，进而产生完全未知的行为。这一问题称为「缓冲区溢出」，这会带来未知的程序错误，同时还有可能被黑客巧妙利用从而进一步攻击你的程序。一个典型的案例是 SONY 在 PSP-3000 游戏机上的相册应用存在一个「缓冲区溢出」漏洞，通过一张特殊的图片，黑客实现了对 PSP-3000 的破解，从而运行黑客指定的第三方程序。

另一类问题则是由隐式类型转换带来的问题。这一类问题的翘楚就是 PHP 和 JavaScript。这两门语言在运算所需类型不满足的情况下，比起抛出错误，更愿意尝试一系列自动的类型转换来满足需求，而这一过程会带来一系列的问题。

比如在 PHP 中著名的 Type Juggling 漏洞，使用 `==` 符号比较两个完全不同的字符串：

```php
if ('0e1234' == '0e5678') {
  echo('wat');
}
```

程序会返回 `wat`，纵使字符串 `0e1234` 和 `0e5678` 完全不相同，但是 PHP 发现了这些字符串都是 `0e` 开始的，于是会认为这 **可能** 是[科学记数法](https://zh.wikipedia.org/wiki/%E7%A7%91%E5%AD%A6%E8%AE%B0%E6%95%B0%E6%B3%95)的数字。而无论 0 的多少次方都是 0，所以两者都是 0，因此认为这两个字符串相等。这显然不是预期行为。这一方法常会在一些特殊情况引发更严重的问题，比如检查用户登录密码时，一般数据库存储哈希运算后的 16 进制密码以防止明文泄漏。而 16 进制数有 $$ \frac{1}{256} $$ 的概率以 `0e` 开头，同时以 `00e`、`000e` 开头的同样也会被以同样的方式处理，因此给定 `N` 位长的字符串，PHP 会有 $$ \sum\limits_{i=2}^n \frac{1}{16^n} $$ 的概率认为其等于 0。

这两类由类型带来的问题是高级语言需要尽力避免的。

在运行过程中不可能出现类型错误问题的，是强类型系统；而如果这门语言在运行过程中会因为类型错误而产生不可知的任意行为的，那么就是弱类型系统。

在编译期（运行程序前）检查类型错误的是静态类型系统，在运行过程中拒绝类型错误的程序继续运行的，则是动态类型系统。

虽然 Ruby 考虑在未来的 3.0 版本中引入静态类型检查系统，目前的 Ruby 2.7 仍是运行时的动态类型检查。但是 Ruby 是强类型语言，会在运行通过抛出类型错误，来避免错误的类型转换带来潜在的风险。

## 函数定义

```ruby
def succ(x)
  x += 1
end
```

### 豆知识：`void` or `nil`?

在 Ruby 中任何方法都有「返回值」，但返回值可能为「空」。这句话听起来非常拗口，我们来简单比较一下。如果我们在 C++ 语言中定义一个函数如下：

```cpp
void void_function() {
  return;
}

int main() {
  auto x = void_function(); // illegal, 非法代码。
  return 0;
}
```

这段代码是非法的，因为 `void_function()` 没有返回值，不能让其结果赋值给 `x`。
